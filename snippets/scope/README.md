# 作用域

## 词法环境（Lexical Environment）

词法环境是一个包含 标识符（变量/函数名）绑定 的结构，记录了当前代码块的变量和函数定义，以及对外部环境的引用（outer）。由以下组成：

- 环境记录（Environment Record）：存储当前作用域内的变量和函数声明。
- 外部词法环境的引用（outer）：指向父级词法环境，形成作用域链。

特点：

- 每个函数、代码块（如 `{}`）都会创建一个新的词法环境。
- `let`、`const` 声明的变量以及 `function` 声明（严格模式下） 存储在词法环境中，并受块级作用域约束。

词法环境的存在也使得在作用域中的变量在声明前无法被使用，这也是“暂时性死区”的由来。

## 变量环境（Variable Environment）

变量环境是词法环境的一个特殊类型，专门用于存储 var 声明的变量和函数声明。与词法环境的区别：

- 在全局或函数执行上下文中，变量环境和词法环境最初是同一个对象。（全局作用域也可看做一个特殊的函数作用域）
- 当进入一个块级作用域（如 `{}` 、`if 语句` 包裹的作用域）时，会创建一个新的词法环境，但变量环境保持不变，因此 var 变量不受块级作用域限制。

特点：

- var 声明的变量会被提升（Hoisting），并存储在变量环境中。
- 非严格模式下，块级作用域中的函数声明也会存储在外层作用域的变量环境中，类似于 `var` 声明，详见 [👇🏻](./function.js)：

  ```js
  console.log(A) // undefined
  // A() // 这里调用会报错

  {
    console.log(A) // [Function: A]
    A() // 打印 a
    function A() {
      console.log('a')
    }
  }

  A() // 打印 a
  ```

这也是为什么 `var` 声明的变量没有块级作用域的原因，也解释了 `var` 有这么多怪异的行为。如：

```js
// 全局作用域

// a 存在于全局作用域，不存在暂时性死区，可在声明前使用，但值为 undefined
console.log(a) // undefined

{
  // 块级作用域，创建新的 词法环境，但变量环境不变
  var a = 1
}

// 所以这里的打印可以成功打印 1
console.log(a) // 1

;(function () {
  // 新的 函数作用域
  {
    // 同样的，创建新的词法环境，但变量环境不变
    var b = 2
  }

  // 所以这里仍可继续打印
  console.log(b) // 2
})()

// 但 var b = 2 仅存在与上面的函数作用域内，与外部是不同的两个变量环境，所以这里会报错，因为 b 在全局作用域中不存在
console.log(b) // Uncaught ReferenceError: b is not defined
```

## 作用域链（Scope Chain）

> 作用域分为：
>
> - 全局作用域：脚本加载时自动创建，始终存在
> - 函数作用域（函数内部）：函数执行时创建，执行完成后销毁
> - 块级作用域（`{}`包含），如 `if`、`for`、`switch` 语句包含的内容：执行到代码块时创建

作用域链是由 **词法环境** 嵌套形成的，各层级之间通过 **词法环境的 outer** 引用连接。
在变量查找时，会从当前词法环境开始，沿着 `outer` 逐级向上查找，直到全局环境。
